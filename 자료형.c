#include <stdio.h>
int main(void)
{
	//자료형의 종류
	//		->문자 / 정수 / 실수
	//문자 : char / 1바이트/-128 ~ 127
	//정수 : short / 2바이트 / -32000 ~ 32000
	//정수 : int / 4바이트 / -21억 ~ 21억
	//정수 : long / 4바이트 / -21억 ~ 21억
	//정수 : long long / 8바이트 
	//실수: float / 4바이트
	//실수 : double / 8바이트
	//실수 : long double / 8바이트 이상

	//char , int , double 많이씀
	//정수 = 분모가 1
	//실수 = 실제로 존재하는 수 
	long long max_num = 2200000000;
	printf("%lld\n", max_num);


	//sign
	
	unsigned int Max_num = 2200000000;
	printf("%u\n", Max_num);

	//signed : 맨왼쪽 비트는 부호비트로 적용됨
	// sigend값 : 0부터 2의 n-1승 -1 / 음수로 표현할때는 2의 n승 
	// n-1승 하는 이유 앞 비트는 음,양 표시 비트기 때문 
	// 음수표현은 왜 -1 을 안해주는가?
	//		 -> 0은 양수로 인식하기에 음수에 포함 X
	//unsigned : 모든 비트는  숫자를 표현할 때 사용됨
	//unsigend 값의 범위 : 0부터 2의 n승 -1  / -1하는 이유 : 0포함이기 때문 
	//부호비트는 0은 양수 1은 음수 


	// 자동형 변환
	//자료형이 안맞으면 선언한 자료형에 맞게 출력
	//			->10.000000이 출력되는걸 확인 
	//%f가 소수점 6자리까지 출력
	//원래 double 은  15~16자리
	double change_num = 10;
	printf("%f\n", change_num);
	printf("%.15f\n", change_num);

	//자동형 변환 2
	//실수 값을 선언해줬지만 정수형인 int 를 사용했기에 정수인 5만 출력 
	//소수점이 없어지는 현상을 "소수부의 손실" 이라고 함 

	int change_num2 = 5.1123;
	printf("%d\n", change_num2);

	//명시적 형 변환
	// short는 int의 축소버전이라 생각하면됨
	//메모리 부족시 , 숫자가 작은 범위에서 움직일시 short사용
	//float : 4바이트 / 프로그램의 속도가 중요할때 /double보다 메모리를 적게 먹기에 이같은게 모이면 속도 향상 가능 
	//double : 8바이트 / 소수점 15~16 자리까지 표현가능 하기에 정교한 작업시 사용하면 좋음 
	printf("%d\n", (int)1.12345);
	printf("%d\n", (short)1.12345);
	printf("%f\n", (double)22);
	printf("%f\n", (float)22);
	return 0;
}
//1. 자료형의 종류
//2. 비트 = 데이터저장,표현에서의 가장 작은 단위
//3. 바이트 = 8비트 = 1바이트 (-128~127/0~255) 표현가능
//4. 값의 범위 
//사인드 - 기본값 맨 왼쪽 차상위 비트를 부호비트로 사용 0=양수 1=음수
//언사인드
//5. sizeof 연산자 값을 직접넣어도 되고 자료형을 넣어 몇 바이트인지 확인가능 
//6.영어와 일부 특수문자는 숫자로 매핑되어 있음 
//7. 상수(리터럴  / 심볼릭 / 매크로)  심볼릭을 많이 사용
//8.자료형과 최기화될 데이터의 자룡이 다르면 변수 자료형에 맞춰자동형 변환이 일어남 
//9. %d - 정수 / %c - 문자 / %f - 실수